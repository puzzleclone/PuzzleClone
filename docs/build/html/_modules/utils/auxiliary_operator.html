

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>utils.auxiliary_operator &mdash; PuzzleClone v0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=2fea6348"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            PuzzleClone
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PuzzleClone</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PuzzleClone</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">utils.auxiliary_operator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for utils.auxiliary_operator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Auxiliary Operator </span>

<span class="sd">This module provides functionality for constructing symbols and conditions, including:</span>
<span class="sd">1. Symbol wrapper (CustomSym)</span>
<span class="sd">2. Condition wrapper (CustomCond)</span>
<span class="sd">3. Utility functions for generating random indices, evaluating conditions, and managing symbol metadata.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">z3</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">contextvars</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<div class="viewcode-block" id="CustomSym">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.CustomSym">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomSym</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Symbol wrapper class supporting structured symbol modeling and Z3 variable integration</span>

<span class="sd">    Attributes:</span>
<span class="sd">        name (str): Symbol group name, used as symbol prefix</span>

<span class="sd">        source (Dict[str, List[Union[str, int]]]): Data source</span>

<span class="sd">            - Example: {&quot;Grade&quot;: [1,2,3], &quot;Subject&quot;: [&quot;Math&quot;, &quot;Chinese&quot;]}</span>

<span class="sd">        attr (Optional[List[str]]): Attributes</span>

<span class="sd">            - Example: [&quot;Score&quot;, &quot;Difficulty&quot;]</span>

<span class="sd">        type (Union[str, List[str]]): Variable type definition, supports:</span>

<span class="sd">            - &#39;Int&#39; (default)/&#39;Bool&#39;/&#39;Real&#39;/&#39;BitVec&#39;</span>

<span class="sd">            - Type list (needs equal length when attr exists)</span>

<span class="sd">        desc (Optional[Union[str, List[str]]]): Description template system</span>

<span class="sd">            - Single attribute mode: &quot;Grade variable description&quot;</span>

<span class="sd">            - Multi-attribute mode: [&quot;Score description&quot;, &quot;Difficulty description&quot;]</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; grade_system = CustomSym(</span>
<span class="sd">        ...     name=&quot;Grade&quot;,</span>
<span class="sd">        ...     source={&quot;Level&quot;: [&quot;A&quot;, &quot;B&quot;]},</span>
<span class="sd">        ...     attr=[&quot;Score&quot;],</span>
<span class="sd">        ...     type=&quot;Int&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; grade_system[(&quot;A&quot;)][&quot;Score&quot;]  # Returns Int(&#39;Grade_A_Score&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">attr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;Int&quot;</span><span class="p">,</span>
        <span class="n">desc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_categories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        
        <span class="c1">#------ 初始化处理流程 ------</span>
        <span class="c1"># 生成笛卡尔积作为复合键</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">source</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        
        <span class="c1"># Z3变量创建逻辑</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#-- 单属性模式 --</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key_variants</span><span class="p">():</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_to_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_z3_var</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
                    <span class="c1"># 为每个变量存储配置</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_store_var_config</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;When attr is None, type must be str&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#-- 多属性模式 --</span>
            <span class="c1"># 校验类型列表长度匹配</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;属性类型列表长度需与属性列表一致&quot;</span><span class="p">)</span>
            
            <span class="c1"># 构建复合属性字典</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_key_variants</span><span class="p">():</span>
                <span class="n">key_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_to_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="n">var_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key_str</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_z3_var</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                    <span class="c1"># 分属性存储元数据</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_store_var_config</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_store_var_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store variable configuration metadata</span>
<span class="sd">        Parameters:</span>
<span class="sd">            var_name: Z3 variable name (e.g., Grade_A_Math_Score)</span>
<span class="sd">            key: Tuple (e.g., (&#39;A&#39;, &#39;Math&#39;))</span>
<span class="sd">            attr: Current processing attribute name (e.g., &#39;Score&#39;)</span>
<span class="sd">        Storage Format:</span>
<span class="sd">            &gt;&gt;&gt; {</span>
<span class="sd">            ...    &quot;p&quot;: {  # Dimension parameters</span>
<span class="sd">            ...         &quot;grade&quot;: &quot;A&quot;,</span>
<span class="sd">            ...         &quot;dim_1&quot;: {</span>
<span class="sd">            ...             &quot;category&quot;: &quot;Subject&quot;,</span>
<span class="sd">            ...             &quot;value&quot;: &quot;Math&quot;,</span>
<span class="sd">            ...             &quot;init_values&quot;: [&quot;Math&quot;, &quot;Chinese&quot;]</span>
<span class="sd">            ...         }</span>
<span class="sd">            ...     },</span>
<span class="sd">            ...     &quot;type&quot;: &quot;int&quot;,  # Variable type</span>
<span class="sd">            ...     &quot;desc&quot;: &quot;Score variable description&quot;  # Original template</span>
<span class="sd">            ... }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 维度值字典构建</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">p_values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">))</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_values</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">key</span><span class="p">}</span>

        <span class="c1"># 类型与描述获取</span>
        <span class="n">current_type</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span> 
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">attr</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">desc_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_var_desc</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

        <span class="c1"># 元数据组装</span>
        <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="n">p_values</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">current_type</span><span class="p">,</span>
            <span class="s2">&quot;desc&quot;</span><span class="p">:</span> <span class="n">desc_template</span>
        <span class="p">}</span>
        
        <span class="c1"># 多维度附加信息</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">config</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="sa">f</span><span class="s2">&quot;dim_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s2">&quot;category&quot;</span><span class="p">:</span> <span class="n">cat</span><span class="p">,</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="s2">&quot;source_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">})</span>
        
        <span class="c1"># 调用全局存储方法</span>
        <span class="n">store_sym_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> 
            <span class="n">config</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_var_desc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract variable description template</span>
<span class="sd">        Returns:</span>
<span class="sd">            str/None: Original description template; placeholder will be kept</span>
<span class="sd">        Example:</span>
<span class="sd">            Input key=(&#39;12&#39;, &#39;Math&#39;), attr=&#39;Score&#39;</span>
<span class="sd">            Return possible template: &quot;the score of the student in Grade {{dim_0}} and Subject {{dim_1}}&quot;</span>
<span class="sd">            </span>
<span class="sd">        仅获取描述模板（不计算具体值）</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
            
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">attr_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="p">[</span><span class="n">attr_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">attr_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_key_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Key value serialization method</span>
<span class="sd">        Rules:</span>
<span class="sd">            - Single-dimensional key: direct stringification (&quot;A&quot;)</span>
<span class="sd">            - Multi-dimensional key (for tuples): underscore connection (&quot;A_Math&quot;)</span>
<span class="sd">        Returns:</span>
<span class="sd">            Standardized key string representation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_key_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get standardized key representation</span>
<span class="sd">        Methods:</span>
<span class="sd">            - Single dimension: returns first-level key list [&quot;A&quot;, &quot;B&quot;]</span>
<span class="sd">            - Multi-dimension: returns tuple key list [(&quot;A&quot;, &quot;Math&quot;), ...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_z3_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">type_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Z3 variable generation</span>

<span class="sd">        Parameters:</span>
<span class="sd">            type_str: Type identifier (case-insensitive)</span>
<span class="sd">                - &#39;int&#39; → z3.Int</span>
<span class="sd">                - &#39;bool&#39; → z3.Bool</span>
<span class="sd">                - &#39;real&#39; → z3.Real</span>
<span class="sd">                - &#39;bv*&#39; → Bit vector (e.g., bv16 → 16-bit)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Z3 variable instance</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When encountering unsupported type identifiers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">type_str</span> <span class="o">=</span> <span class="n">type_str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">type_str</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Int</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">type_str</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Bool</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">type_str</span> <span class="o">==</span> <span class="s2">&quot;real&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Real</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">type_str</span> <span class="o">==</span> <span class="s2">&quot;bitvec&quot;</span> <span class="ow">or</span> <span class="n">type_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;bv&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">type_str</span> <span class="o">==</span> <span class="s2">&quot;bitvec&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># 默认8位</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 处理类似&quot;bv16&quot;的格式</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bits</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">type_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                    <span class="k">return</span> <span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bits</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported Z3 type: </span><span class="si">{</span><span class="n">type_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>

<div class="viewcode-block" id="CustomSym.get">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.CustomSym.get">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Batch retrieve all variable instances of the specified attribute.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            attr: Target attribute name</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of attribute variables/instances arranged in the order of initialization.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: When attr does not exist or is currently in single-attribute mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;单属性模式请直接使用values()遍历&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;不存在的属性 &#39;</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span></div>


<div class="viewcode-block" id="CustomSym.to_list">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.CustomSym.to_list">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output a list of Z3 symbols.</span>

<span class="sd">        Returns</span>
<span class="sd">        </span>
<span class="sd">        - Single attribute: [Var1, Var2, ...]</span>

<span class="sd">        - Multiple attributes: [[Attribute1 variable list], [Attribute2 variable list], ...]</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; # Example of multiple attributes and multiple dimensions</span>
<span class="sd">            ... [</span>
<span class="sd">            ...     [Grade_A_Math_Score, Grade_A_Chinese_Score, ...],  # Score attribute</span>
<span class="sd">            ...     [Grade_A_Math_Diff, Grade_A_Chinese_Diff, ...]    # Difficulty attribute</span>
<span class="sd">            ... ]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span> 
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span>
        <span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enhanced accessing values by key in dict</span>

<span class="sd">        Features:</span>
<span class="sd">            - Automatically handles single-dimensional key wrapping</span>
<span class="sd">            - Enforces multi-dimensional keys to be accessed in tuple form</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: Multi-dimensional access not using tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 自动化解包单维元组</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">key</span>
            <span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;多维键必须使用tuple形式访问&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="CustomCond">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.CustomCond">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomCond</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Condition wrapper class for structured condition modeling</span>

<span class="sd">    Extends metadata support based on the standard string class to achieve:</span>
<span class="sd">    - Binding of conditional expressions to descriptive text</span>
<span class="sd">    - Domain identification classification</span>
<span class="sd">    - Additional data payload</span>

<span class="sd">    Attributes:</span>
<span class="sd">        domain (int): Number of expressions</span>
<span class="sd">        data (list): Additional data payload</span>

<span class="sd">    Inherits:</span>
<span class="sd">        All native functionalities and methods of str</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; cond = CustomCond(domain=1, desc=&quot;Score should be greater than 60&quot;, data=[[...], [...]])</span>
<span class="sd">        &gt;&gt;&gt; print(cond)  # &quot;Score should be greater than 60&quot;</span>
<span class="sd">        &gt;&gt;&gt; cond.domain  # 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># 确保字符串实例化正确</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">desc</span><span class="p">)</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">_desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="n">instance</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">instance</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">desc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: Natural langauge description&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="nd">@desc</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">desc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_desc</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># 由于str是不可变类型，这里需要重新创建实例</span>

    <span class="c1"># 核心字符串协议实现</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomCond</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CustomCond</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_desc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>


<span class="n">_sym_config</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># 储存所有symbol的相关信息，包括其依赖的变量p、描述方式等</span>
<span class="n">_user_context_global</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_user_context_local</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 全局计数器，用于生成英文字母时的序列控制</span>

<div class="viewcode-block" id="store_sym_config">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.store_sym_config">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">store_sym_config</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">_sym_config</span><span class="p">[</span><span class="n">_convert_to_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_sym_config</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="set_global_context">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.set_global_context">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_global_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_user_context_global</span>
    <span class="n">_user_context_global</span> <span class="o">=</span> <span class="n">ctx</span></div>


<div class="viewcode-block" id="set_local_context">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.set_local_context">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_local_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_user_context_local</span>
    <span class="n">_user_context_local</span> <span class="o">=</span> <span class="n">ctx</span></div>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_hashable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively convert lists/tuples to tuples to ensure hashability.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_convert_to_hashable</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
<div class="viewcode-block" id="get_p">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.get_p">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_p</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the value of the binded variable named &#39;p&#39; for the symbol &#39;sym&#39;; if &#39;sym&#39; is a list, do this for each element.&quot;&quot;&quot;</span>
    <span class="c1"># if isinstance(sym, (list, tuple)):</span>
    <span class="c1">#     return type(sym)(get_p(item, p) for item in sym)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">_convert_to_hashable</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
    <span class="c1"># print(key, _sym_config)</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_sym_config</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sym_config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="s2">&quot;p&quot;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">sym</span><span class="p">)(</span><span class="n">get_p</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sym</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find the p of </span><span class="si">{</span><span class="n">sym</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_desc">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.get_desc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_desc</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the description of the symbol &#39;sym&#39;; if &#39;sym&#39; is a list, do this for each element.&quot;&quot;&quot;</span>
    <span class="c1"># if isinstance(sym, (list, tuple)):</span>
    <span class="c1">#     return type(sym)(get_desc(item) for item in sym)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">_convert_to_hashable</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
    <span class="c1"># print(key, _sym_config)</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_sym_config</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sym_config</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;desc&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">sym</span><span class="p">)(</span><span class="n">get_desc</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sym</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find the description of </span><span class="si">{</span><span class="n">sym</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_data">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.get_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_data</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the random data bound to the condition &#39;sym&#39;; if &#39;sym&#39; is a list, do this for each element.&quot;&quot;&quot;</span>
    <span class="c1"># if isinstance(sym, (list, tuple)):</span>
    <span class="c1">#     return type(sym)(get_desc(item) for item in sym)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">_convert_to_hashable</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
    <span class="c1"># print(key, _sym_config)</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_sym_config</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_sym_config</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">cond</span><span class="p">)(</span><span class="n">get_data</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find the binded data of </span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> </div>

    
<div class="viewcode-block" id="get_value">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.get_value">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_value</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">vars</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the values of &#39;vars&#39; in the solution &#39;sol&#39; of the z3-solver.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">get_value</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">vars</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="nb">vars</span><span class="o">.</span><span class="n">decl</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">is_true</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># 确保布尔值正确转换</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">IntNumRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span>  <span class="c1"># 将Z3整数转为Python int</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">RatNumRef</span><span class="p">):</span>
            <span class="c1"># Z3 有理数 → Python float（例如 Real 类型的解）</span>
            <span class="n">decimal_str</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">as_decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            <span class="c1"># 去除末尾的问号（如果存在）</span>
            <span class="k">if</span> <span class="n">decimal_str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;?&#39;</span><span class="p">):</span>
                <span class="n">decimal_str</span> <span class="o">=</span> <span class="n">decimal_str</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">decimal_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">AlgebraicNumRef</span><span class="p">):</span>
            <span class="c1"># 处理代数数（罕见情况，可能需要近似）</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">approx</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">as_decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># 取 10 位小数</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="get_var_name">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.get_var_name">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_var_name</span><span class="p">(</span><span class="n">z3_var</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the string representation of the variable name of the z3 variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">z3_var</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">()</span></div>


<div class="viewcode-block" id="is_option_valid">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.is_option_valid">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_option_valid</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
    <span class="n">compiled_formula</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>
    <span class="n">check</span> <span class="o">=</span> <span class="nb">all</span> <span class="k">if</span> <span class="n">cond</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span> <span class="k">else</span> <span class="nb">any</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">compiled_formula</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="n">env</span><span class="p">,</span> <span class="s2">&quot;_model&quot;</span><span class="p">:</span> <span class="n">_model</span><span class="p">,</span> <span class="s2">&quot;_opt&quot;</span><span class="p">:</span> <span class="n">opt</span><span class="p">})</span> <span class="k">for</span> <span class="n">_model</span> <span class="ow">in</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;_solutions&quot;</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span> <span class="o">!=</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to evaluate the options.&quot;</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="generate_random_indices">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.generate_random_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_random_indices</span><span class="p">(</span><span class="n">choose</span><span class="p">,</span> <span class="n">amount</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">domain_cond</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim_cond</span><span class="o">=</span><span class="p">[],</span> <span class="n">custom_cond</span><span class="o">=</span><span class="p">[],</span> <span class="n">order</span><span class="o">=</span><span class="p">[],</span> <span class="n">duplicate</span><span class="o">=</span><span class="p">[],</span> <span class="n">env</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random index combinations.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        choose (List[any]): Number of available elements in each data source, similar to DerivedSymbol.source.</span>
<span class="sd">        amount (List[int]): Number of elements to choose in each data source, similar to DerivedSymbol.amount.</span>
<span class="sd">            Example: [&quot;2&quot;, &quot;1&quot;] indicates selecting 2 from the first data source and 1 from the second source.</span>
<span class="sd">        domain (int): Total number of groups to select, similar to DerivedSymbol.domain.</span>
<span class="sd">        domain_cond (bool): Same as DerivedSymbol.domain_cond, default True.</span>
<span class="sd">        dim (int): Number of dimensions in each symbol, similar to DerivedSymbol.dim.</span>
<span class="sd">        dim_cond (List[List[int]]): Same as DerivedSymbol.dim_cond.</span>
<span class="sd">        custom_cond (List[Dict]): List of custom constraints, each dictionary contains: (Same as DerivedSymbol.custom_cond)</span>
<span class="sd">            - scope: Level of application (&#39;dim&#39;/&#39;domain&#39;).</span>
<span class="sd">            - fields: List of indices of the involved data sources.</span>
<span class="sd">            - constraint: Logical expression for constraints (callable object).</span>
<span class="sd">        order (List[bool]): Configuration of arrangement for each dimension. Same as DerivedSymbol.order.</span>
<span class="sd">            - True: Arrangement (considering order).</span>
<span class="sd">            - False: Combination (not considering order).</span>
<span class="sd">        duplicate (List[bool]): Initialization repetition rules. Same as DerivedSymbol.duplicate.</span>
<span class="sd">            - True: Allow repeated selections.</span>
<span class="sd">            - False: Prohibit repetition.</span>
<span class="sd">        env (Dict): Importing the environment variables from code generated by the translator. Used for evaluating some conditional expressions in custom_cond.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (Selected indices, Formatted selected indices)</span>
<span class="sd">        </span>
<span class="sd">            - Example: ([[[1, 2], [3]], [[4, 5], [6]]], [&quot;__1__, __2__&quot;, &quot;__3__&quot;])</span>

<span class="sd">            - Note: The formatted indices are for configuration purposes, not for direct use in the program. In config files, strings that start and end with &quot;__&quot; are considered as indices rather than values.</span>

<span class="sd">    Raises:</span>
<span class="sd">        AssertionError: Raised when parameter lengths do not match.</span>
<span class="sd">        Exception: Raised when unable to generate valid combinations.</span>

<span class="sd">    Implementation Process:</span>
<span class="sd">        1. Parameter validation and initialization.</span>
<span class="sd">        2. Generate a base pool of combinations based on the provided choose and amount.</span>
<span class="sd">        3. Handling custom conditions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">amount</span><span class="p">))</span> 

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">order</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">duplicate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">duplicate</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="n">duplicate</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span>
    <span class="n">choose_lens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">choose</span><span class="p">]</span>
    <span class="n">ran</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">choose_lens</span><span class="p">]</span>
    <span class="n">subdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choose</span><span class="p">)</span>

    <span class="c1"># 定义生成选项池的辅助函数</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_pool</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">amount_j</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">order</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">duplicate</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">ran</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">amount_j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">permutations</span><span class="p">(</span><span class="n">ran</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">amount_j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">duplicate</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">ran</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">amount_j</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pool</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">ran</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">amount_j</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">]</span>

    <span class="c1"># 第一步处理：先处理dim conditions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dim_cond</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">))]</span>
    <span class="n">flat_dim_cond</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dim_cond</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">row</span><span class="p">]</span>
    <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">))</span> <span class="c1"># 验证dim_cond不能有重复元素</span>
    <span class="n">combs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dim_cond</span><span class="p">:</span>
        <span class="n">pools_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_pool</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span> <span class="c1"># 3维: len(c) * (permutation_num * amount)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">prod_tuple</span><span class="p">]</span> <span class="k">for</span> <span class="n">prod_tuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">pools_per_dim</span><span class="p">)]</span> <span class="c1"># 3维 product_num * len(c) * amount</span>
        <span class="n">comb_dim</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">comb_item</span><span class="p">)</span> <span class="k">for</span> <span class="n">comb_item</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">]</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">dim</span><span class="p">)]</span> <span class="c1"># 4维 comb_num * dim * (len(c) * amount)</span>
        <span class="n">combs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">comb_dim</span><span class="p">))</span> <span class="c1"># 5维 len(dim_cond) * comb_num * dim * (len(c) * amount)</span>
    <span class="n">combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">combs</span><span class="p">))</span> <span class="c1"># 5维 product_num&#39; * len(dim_cond) * dim * (len(c) * amount)</span>
    <span class="n">combs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">subitem</span> <span class="k">for</span> <span class="n">subitem</span> <span class="ow">in</span> <span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">combs</span><span class="p">]</span>  <span class="c1"># Remove outer tuples</span>
    <span class="c1"># combs = np.array(combs).tolist()</span>
    <span class="n">combs_new</span> <span class="o">=</span> <span class="p">[[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="c1"># 先合并倒数第二维</span>
                <span class="n">record_per_dim</span> <span class="o">=</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                <span class="n">new_record_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span>
                <span class="c1"># print(i, j, k, record_per_dim, len(dim_cond[j]), len(record_per_dim))</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_per_dim</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">[</span><span class="n">j</span><span class="p">])):</span>
                    <span class="n">field_idx</span> <span class="o">=</span> <span class="n">dim_cond</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
                    <span class="n">new_record_per_dim</span><span class="p">[</span><span class="n">field_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">record_per_dim</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="c1"># print(combs[i][j][k], new_record_per_dim, combs[1][0][0])</span>
                <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_record_per_dim</span><span class="p">)</span> <span class="c1"># 5维 product_num&#39; * len(dim_cond) * dim * subdim * amount</span>
                <span class="c1"># print(combs[i][j][k], new_record_per_dim, combs[1][0][0])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)):</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">))</span>
        <span class="c1"># 再对dim_cond进行合并</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim_cond</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">merged</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
            <span class="n">combs_new</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>

    <span class="c1"># print(combs_new[0]) # 4维 product_num&#39; * dim * subdim * amount</span>

    <span class="c1"># 第二步处理custom conditions</span>
    <span class="n">custom_dim_cond</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;scope&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;dim&#39;</span><span class="p">,</span> <span class="n">custom_cond</span><span class="p">))</span>
    <span class="n">custom_domain_cond</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;scope&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;domain&#39;</span><span class="p">,</span> <span class="n">custom_cond</span><span class="p">))</span>
    <span class="n">custom_option_cond</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="s1">&#39;scope&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;option&#39;</span><span class="p">,</span> <span class="n">custom_cond</span><span class="p">))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">source_filter</span><span class="p">(</span><span class="n">candidate_comb</span><span class="p">):</span> <span class="c1"># 先对已经能判断的dim类custom condition进行一遍预过滤</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># print(candidate_comb)</span>
        <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">custom_dim_cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">)):</span> <span class="c1"># 如果当前cond涉及到的fields全部已经随机过，执行过滤</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">candidate_comb</span><span class="p">:</span>
                    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">item</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">]])</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s2">&quot;constraint&quot;</span><span class="p">])</span>
                <span class="c1"># print(l, func(l))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ok</span>
    <span class="n">combs_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">source_filter</span><span class="p">,</span> <span class="n">combs_new</span><span class="p">))</span>


    <span class="c1"># 计算剩余dim类custom condition中未处理的fields</span>
    <span class="n">field_idxs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">custom_dim_cond</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">)):</span> <span class="c1"># 如果当前cond涉及到的fields全部未随机过，先进行随机</span>
            <span class="n">field_idxs</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s2">&quot;fields&quot;</span><span class="p">])</span>
    <span class="n">field_idxs</span> <span class="o">-=</span> <span class="nb">set</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">)</span> <span class="c1"># 剩余的为尚未随机过的fields</span>
    <span class="n">field_idxs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">field_idxs</span><span class="p">)</span>
    <span class="c1"># 对剩余dim类custom condition中未处理的fields进行随机，与之前的结果合并</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pools_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_pool</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">amount</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">field_idxs</span><span class="p">]</span> <span class="c1"># 3维: len(field_idxs) * (permutation_num * amount)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">prod_tuple</span><span class="p">]</span> <span class="k">for</span> <span class="n">prod_tuple</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">pools_per_dim</span><span class="p">)]</span> <span class="c1"># 3维 product_num * len(field_idxs) * amount</span>
        <span class="n">combs</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">list</span><span class="p">(</span><span class="n">comb_item</span><span class="p">)</span> <span class="k">for</span> <span class="n">comb_item</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">]</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dim</span><span class="p">)]</span> <span class="c1"># 4维 comb_num * dim * (len(field_idxs) * amount)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)):</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">dim</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="c1"># 先合并倒数第二维</span>
                <span class="n">record_per_dim</span> <span class="o">=</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">new_record_per_dim</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">field_idxs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">record_per_dim</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">field_idxs</span><span class="p">)):</span>
                    <span class="n">field_idx</span> <span class="o">=</span> <span class="n">field_idxs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                    <span class="n">new_record_per_dim</span><span class="p">[</span><span class="n">field_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">record_per_dim</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_record_per_dim</span> <span class="c1"># 4维 comb_num * dim * subdim * amount</span>
        
        <span class="n">combs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">combs_new</span><span class="p">,</span> <span class="n">combs</span><span class="p">))</span> <span class="c1"># 5维 product_num&#39; * 2 * dim * subdim * amount</span>
        <span class="n">combs_new</span> <span class="o">=</span> <span class="p">[[[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">))]</span> <span class="c1"># 4维 product_num&#39; * dim * subdim * amount</span>
        <span class="c1"># 再对dim_cond进行合并</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">merged</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">combs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
                <span class="n">combs_new</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span> 

        <span class="c1"># 二次过滤</span>
        <span class="n">flat_dim_cond</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flat_dim_cond</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">field_idxs</span><span class="p">))</span>
        <span class="n">combs_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">source_filter</span><span class="p">,</span> <span class="n">combs_new</span><span class="p">))</span> <span class="c1"># 4维 product_num&#39; * dim * subdim * amount</span>

    <span class="c1"># 第三步：随机选取domain组，并将剩余未随机的部分随机化</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid</span><span class="p">(</span><span class="n">combs</span><span class="p">,</span> <span class="n">conds</span><span class="p">):</span>
        <span class="c1"># 判断选出的部分是否满足custom domain condition</span>
        <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="s1">&#39;fields&#39;</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">[</span>  <span class="p">[</span> <span class="p">[</span><span class="n">comb_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">[</span><span class="s1">&#39;fields&#39;</span><span class="p">]]</span> <span class="k">for</span> <span class="n">comb_dim</span> <span class="ow">in</span> <span class="n">comb</span> <span class="p">]</span> <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combs</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">combs</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;constraint&#39;</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">constraint</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s1">&#39;constraint&#39;</span><span class="p">],</span> <span class="p">{</span><span class="o">**</span><span class="n">env</span><span class="p">,</span> <span class="o">**</span><span class="nb">globals</span><span class="p">()})</span>
                <span class="k">else</span><span class="p">:</span>  
                    <span class="n">constraint</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cond</span><span class="p">[</span><span class="s1">&#39;constraint&#39;</span><span class="p">])</span>
                
                <span class="c1"># Handle both function and boolean cases</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">constraint</span>  <span class="c1"># Create a function that always returns the boolean</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">constraint</span>  <span class="c1"># It&#39;s already a function</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="p">(</span><span class="n">to_hashable</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    
    
    <span class="n">max_attempts</span> <span class="o">=</span> <span class="mi">1000</span>  <span class="c1"># 设定最大尝试次数</span>

    <span class="c1"># 原有条件检查（确保domain_cond为True时有足够元素）</span>
    <span class="k">if</span> <span class="n">domain_cond</span> <span class="ow">and</span> <span class="n">domain</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">combs_new</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Fail to generate sufficient random indices to fulfill all conditions&quot;</span><span class="p">)</span>

    <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">res_combs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_attempts</span><span class="p">):</span>
        <span class="c1"># 生成候选组合</span>
        <span class="k">if</span> <span class="n">domain_cond</span><span class="p">:</span>
            <span class="n">current_candidates</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">combs_new</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">current_candidates</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">combs_new</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">domain</span><span class="p">)</span>
        
        <span class="c1"># 深拷贝避免污染原始数据</span>
        <span class="n">temp_candidates</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">current_candidates</span><span class="p">)</span>
        
        <span class="c1"># 处理None值（随机填充）</span>
        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">temp_candidates</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comb_dim</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">comb_dim</span><span class="p">)</span> <span class="o">==</span> <span class="n">subdim</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subdim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">comb_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">comb_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">ran</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">amount</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        
        <span class="c1"># 有效性检查</span>
        <span class="c1"># if is_option_valid(temp_candidates, custom_option_cond, choose, env) and is_valid(temp_candidates, custom_domain_cond):</span>
        <span class="c1">#     res_combs = temp_candidates</span>
        <span class="c1">#     valid = True</span>
        <span class="c1">#     break</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">custom_option_cond</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 外部场景是生成选择题选项</span>
            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">custom_option_cond</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 选择题只能有一个验证公式</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">custom_option_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># 将下标带入实际的符号，用于后续判断</span>
            <span class="n">_opts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">temp_candidates</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 选项的dim应当为1</span>
                <span class="n">_opts</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">choose</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])</span>
            
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">is_option_valid</span><span class="p">(</span><span class="n">_opt</span><span class="p">,</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;formula&quot;</span><span class="p">],</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;cond&quot;</span><span class="p">],</span> <span class="n">cond</span><span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">],</span> <span class="n">env</span><span class="p">)</span> <span class="k">for</span> <span class="n">_opt</span> <span class="ow">in</span> <span class="n">_opts</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">temp_candidates</span><span class="p">,</span> <span class="n">custom_domain_cond</span><span class="p">):</span>
                <span class="n">res_combs</span> <span class="o">=</span> <span class="n">temp_candidates</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 外部场景是生成condition</span>
            <span class="k">if</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">temp_candidates</span><span class="p">,</span> <span class="n">custom_domain_cond</span><span class="p">):</span>
                <span class="n">res_combs</span> <span class="o">=</span> <span class="n">temp_candidates</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to generate valid combs after </span><span class="si">{</span><span class="n">max_attempts</span><span class="si">}</span><span class="s2"> attempts&quot;</span><span class="p">)</span>

    <span class="c1"># 当dim为1时，简化该维</span>
    <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res_combs</span><span class="p">)):</span>
            <span class="n">res_combs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_combs</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">res_to_str</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">res_to_str</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">arr</span><span class="si">}</span><span class="s2">__&quot;</span>

            
    <span class="n">res_combs_str</span> <span class="o">=</span> <span class="n">res_to_str</span><span class="p">(</span><span class="n">res_combs</span><span class="p">)</span>
    <span class="c1"># print(res_combs)</span>
    <span class="k">return</span> <span class="n">res_combs</span><span class="p">,</span> <span class="n">res_combs_str</span></div>

    
    

<div class="viewcode-block" id="generate_letters">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.generate_letters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_letters</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s1">&#39;en&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a set of letter identifiers.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        n (int): The number of identifiers to generate.</span>
<span class="sd">        lang (str): Language option, &#39;en&#39; for English (default), other values for Chinese.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: In English mode, returns a list formatted like [&#39;A1&#39;, &#39;A2&#39;, ...].</span>
<span class="sd">        str: In Chinese mode, returns a string containing the specified number of characters.</span>

<span class="sd">    Description:</span>

<span class="sd">    - English mode: Uses a looped sequence of letters A-Z combined with numbers (resets letters every 26 iterations).</span>
<span class="sd">    </span>
<span class="sd">    - Chinese mode: Uses a fixed alphabet &quot;甲乙丙丁...&quot; to return the first n characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">cnt</span>
    <span class="k">if</span> <span class="n">lang</span><span class="o">==</span><span class="s1">&#39;en&#39;</span><span class="p">:</span>
        <span class="c1"># 计算当前起始字母：按26字母循环（A=0, B=1,... Z=25）</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span><span class="p">[</span><span class="n">cnt</span> <span class="o">%</span> <span class="mi">26</span><span class="p">]</span>
        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># 更新全局计数器</span>
        <span class="c1"># 生成字母+数字序列（如 [&#39;A1&#39;, &#39;A2&#39;, ..., &#39;An&#39;]）</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CN_names</span> <span class="o">=</span> <span class="s2">&quot;甲乙丙丁戊己庚辛壬癸子丑寅卯辰巳午未申酉戌亥&quot;</span>
        <span class="c1"># 返回前n个汉字组成的字符串</span>
        <span class="k">return</span> <span class="n">CN_names</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span></div>

        

<div class="viewcode-block" id="generate_var_names">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.generate_var_names">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_var_names</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array of default variable names with a length of n. </span>

<span class="sd">    - When n &lt;= 3, the order is x, y, z.</span>
<span class="sd">    - When 4 &lt;= n &lt;= 11, the order is p, q, r, ... .</span>
<span class="sd">    - When n &gt; 11, the order is x1, x2, ... .</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span>
    <span class="k">elif</span> <span class="mi">3</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">11</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span></div>


<div class="viewcode-block" id="generate_random_list">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.generate_random_list">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_random_list</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ele_type</span><span class="p">,</span> <span class="n">ele_domain</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="p">[],</span> <span class="n">per_ele_domain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a random array with element-level range control.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        size (int): Length of the array.</span>
<span class="sd">        ele_type (str): Type of elements in the array, such as &#39;int&#39;, &#39;bool&#39;, &#39;enum&#39;, &#39;float&#39;.</span>
<span class="sd">        ele_domain (list or tuple): Global value range for elements (used when element-level range is not defined).</span>
<span class="sd">        cond (list): List of conditions that elements must satisfy, each as a function string, e.g., &quot;lambda l: sum(l) == 5&quot;.</span>
<span class="sd">        per_ele_domain (list, optional): Independent value range for each element, must have the same length as size. Can be None or contain None values, indicating that the element should use the global value range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 参数有效性检查</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size must be a positive integer&quot;</span><span class="p">)</span>
    
    <span class="n">supported_types</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;enum&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ele_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_types</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported element type: </span><span class="si">{</span><span class="n">ele_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># 验证全局值域 ele_domain</span>
    <span class="k">if</span> <span class="n">ele_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ele_domain must have at least two elements for int/float types&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ele_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ele_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ele_domain[0] must be &lt;= ele_domain[1] for int/float types&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ele_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="s1">&#39;enum&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ele_domain must be a non-empty list/tuple for </span><span class="si">{</span><span class="n">ele_type</span><span class="si">}</span><span class="s2"> type&quot;</span><span class="p">)</span>
    
    <span class="c1"># 检查 per_ele_domain 参数 (如提供)</span>
    <span class="k">if</span> <span class="n">per_ele_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_ele_domain</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;per_ele_domain length must match size&quot;</span><span class="p">)</span>
        
        <span class="c1"># 验证每个元素的值域格式（忽略None值）</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">per_ele_domain</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># 该元素使用全局值域</span>
                
            <span class="k">if</span> <span class="n">ele_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain for index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: must be list/tuple with [min, max]&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain for index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: min must be &lt;= max&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ele_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bool&#39;</span><span class="p">,</span> <span class="s1">&#39;enum&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain for index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: must be non-empty list/tuple&quot;</span><span class="p">)</span>
    
    <span class="c1"># 转换条件字符串为函数</span>
    <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 假设存在上下文变量 _user_context_global 和 _user_context_local</span>
            <span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="p">(</span><span class="n">_user_context_global</span> <span class="ow">or</span> <span class="p">{}),</span><span class="o">**</span><span class="p">(</span><span class="n">_user_context_local</span> <span class="ow">or</span> <span class="p">{}),</span><span class="o">**</span><span class="nb">globals</span><span class="p">()}))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid condition string: </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># 生成满足条件的列表</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># 生成候选列表</span>
        <span class="n">lst</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># 确定当前元素的值域（优先使用元素级值域，None表示使用全局值域）</span>
            <span class="k">if</span> <span class="n">per_ele_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">per_ele_domain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_domain</span> <span class="o">=</span> <span class="n">per_ele_domain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_domain</span> <span class="o">=</span> <span class="n">ele_domain</span>
            
            <span class="c1"># 根据元素类型生成随机值</span>
            <span class="k">if</span> <span class="n">ele_type</span> <span class="o">==</span> <span class="s1">&#39;int&#39;</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">current_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">ele_type</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">current_domain</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ele_type</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">current_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">current_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ele_type</span> <span class="o">==</span> <span class="s1">&#39;enum&#39;</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">current_domain</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported element type&quot;</span><span class="p">)</span>
            <span class="n">lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        
        <span class="c1"># 检查条件</span>
        <span class="n">satisfied</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">cond_func</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cond_func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="n">satisfied</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">satisfied</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">satisfied</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lst</span></div>

        
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>

<div class="viewcode-block" id="generate_random_list_with_total">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.generate_random_list_with_total">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_random_list_with_total</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ele_domain</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">per_ele_domain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a random integer array with a total sum of total, supporting element-level range control.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        size (int): Length of the array.</span>
<span class="sd">        ele_domain (list or tuple): Global value range for elements (two integers: [min, max]).</span>
<span class="sd">        total (int): The total sum of all elements in the array.</span>
<span class="sd">        per_ele_domain (list, optional): Independent value range for each element, must have the same length as size. Can be None or contain None values, indicating that the element should use the global value range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 参数有效性检查</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size must be a positive integer&quot;</span><span class="p">)</span>
    
    <span class="c1"># 检查全局值域格式</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ele_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ele_domain must be a list/tuple of two integers&quot;</span><span class="p">)</span>
    <span class="n">min_global</span><span class="p">,</span> <span class="n">max_global</span> <span class="o">=</span> <span class="n">ele_domain</span>
    <span class="k">if</span> <span class="n">min_global</span> <span class="o">&gt;</span> <span class="n">max_global</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ele_domain[0] must be &lt;= ele_domain[1]&quot;</span><span class="p">)</span>
    
    <span class="c1"># 检查 per_ele_domain 参数 (如提供)</span>
    <span class="n">min_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">per_ele_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">per_ele_domain</span><span class="p">)</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;per_ele_domain length must match size&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">per_ele_domain</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_global</span><span class="p">)</span>
                <span class="n">max_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_global</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain for index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: must be list/tuple of two integers&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid domain for index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: min must be &lt;= max&quot;</span><span class="p">)</span>
                <span class="n">min_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">max_arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_global</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
        <span class="n">max_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_global</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="c1"># 计算最小总和与最大总和</span>
    <span class="n">min_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">min_arr</span><span class="p">)</span>
    <span class="n">max_sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">max_arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="n">min_sum</span> <span class="ow">or</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="n">max_sum</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total=</span><span class="si">{</span><span class="n">total</span><span class="si">}</span><span class="s2"> is out of range. It must be in [</span><span class="si">{</span><span class="n">min_sum</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">max_sum</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="n">min_sum</span>  <span class="c1"># 需要分配的总增量</span>
    <span class="c1"># 如果无需增量，直接返回最小值列表</span>
    <span class="k">if</span> <span class="n">R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">min_arr</span>

    <span class="c1"># 计算每个元素的可分配空间</span>
    <span class="n">space_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    <span class="n">total_space</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">space_arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">total_space</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal error: total_space &lt; R&quot;</span><span class="p">)</span>

    <span class="c1"># 基础分配: 按比例分配基础增量</span>
    <span class="n">increment</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
    <span class="n">base_assigned</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">total_space</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 避免除零</span>
            <span class="n">base_inc</span> <span class="o">=</span> <span class="p">(</span><span class="n">space_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">//</span> <span class="n">total_space</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_inc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">increment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_inc</span>
        <span class="n">base_assigned</span> <span class="o">+=</span> <span class="n">base_inc</span>

    <span class="n">rem</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="n">base_assigned</span>  <span class="c1"># 剩余待分配增量</span>

    <span class="c1"># 如果还有剩余增量，则进行随机分配</span>
    <span class="k">if</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># 初始化剩余空间列表</span>
        <span class="n">remaining_space</span> <span class="o">=</span> <span class="p">[</span><span class="n">space_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">increment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="c1"># 创建一个权重数组，用于随机选择</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">remaining_space</span><span class="p">[:]</span>
        <span class="n">total_remaining</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">remaining_space</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">total_remaining</span> <span class="o">&lt;</span> <span class="n">rem</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Internal error: total_remaining &lt; rem&quot;</span><span class="p">)</span>
        
        <span class="c1"># 批量分配剩余增量</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rem</span><span class="p">):</span>
            <span class="c1"># 根据权重随机选择一个索引</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_remaining</span><span class="p">)</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">acc</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">acc</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">:</span>
                    <span class="c1"># 增加选定元素的增量</span>
                    <span class="n">increment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 权重减少但至少为0</span>
                    <span class="n">total_remaining</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">break</span>

    <span class="c1"># 构建最终结果</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">increment</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="choose">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.choose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">choose</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">group_size</span><span class="p">,</span> <span class="n">group_num</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Select group_num tuples of length group_size from a set of symbols/events (candidates).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">candidates</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="c1"># 生成所有唯一的组合，确保顺序不影响</span>
    <span class="n">unique_combinations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">group_size</span><span class="p">):</span>
        <span class="n">unique_combinations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
    <span class="n">all_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">unique_combinations</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">group_num</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">group_num</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">group_num</span> <span class="o">//</span> <span class="n">m</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">group_num</span> <span class="o">%</span> <span class="n">m</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># 添加基数次数的组合，每次打乱顺序</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
            <span class="n">shuffled</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shuffled</span><span class="p">)</span>
        
        <span class="c1"># 处理余数部分</span>
        <span class="k">if</span> <span class="n">remainder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shuffled_remainder</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_combinations</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shuffled_remainder</span><span class="p">[:</span><span class="n">remainder</span><span class="p">])</span>
        
        <span class="c1"># 打乱整个结果列表以确保随机性</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    
<span class="c1"># def mapSolutionsToVar(satisfied_solutions, unsatisfied_solutions, events):</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     将z3.solver的解(_solution)转换为答案</span>
<span class="c1">#     返回一个list，每个元素为一个tuple，包含每组解中的变量</span>
<span class="c1">#     &#39;&#39;&#39;</span>
<span class="c1">#     def work(sols):</span>
<span class="c1">#         res = []</span>
<span class="c1">#         for solution in sols:</span>
<span class="c1">#             vars = []</span>
<span class="c1">#             for var in solution:</span>
<span class="c1">#                 tmp = get_p</span>
<span class="c1">#                 vars.append(tmp)</span>
<span class="c1">#             res.append(tuple(vars))</span>
<span class="c1">#         return res</span>
<span class="c1">#     return work(satisfied_solutions), work(unsatisfied_solutions)</span>


<div class="viewcode-block" id="SafeTemplate">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.SafeTemplate">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SafeTemplate</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="n">template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parsed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_syntax</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_call_func_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;解析被调用函数名称&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Attribute</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">attr</span>
        <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_syntax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;通过AST验证模板语法安全性&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;eval&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
                <span class="c1"># 禁止以下不安全结构</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
                    <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_call_func_name</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_user_context_global</span> <span class="ow">and</span> <span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_user_context_local</span> <span class="ow">and</span> <span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;禁止调用的函数: </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># if isinstance(node, ast.Subscript):</span>
                <span class="c1">#     raise ValueError(&quot;禁止下标操作&quot;)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="SafeTemplate.render">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.SafeTemplate.render">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;string&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;eval&quot;</span><span class="p">)</span>
            <span class="c1"># print(code, context, f&quot;f{repr(self.template)}&quot;, get_p(context[&quot;_operand_l&quot;], &quot;names&quot;))</span>
            <span class="c1"># print(context[&quot;students&quot;], context[&quot;_index&quot;])</span>
            <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;__builtins__&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span> <span class="n">context</span><span class="p">)</span> 
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span></div>
</div>

<span class="c1"># def generate_events(config):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     生成带自然语言描述的逻辑表达式</span>
<span class="c1">#     返回: tuple (z3_expr, description)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     op_translation = {</span>
<span class="c1">#         &#39;eq&#39;: (&#39;==&#39;, &#39;等于&#39;),</span>
<span class="c1">#         &#39;neq&#39;: (&#39;!=&#39;, &#39;不等于&#39;),</span>
<span class="c1">#         &#39;lt&#39;: (&#39;&lt;&#39;, &#39;小于&#39;),</span>
<span class="c1">#         &#39;gt&#39;: (&#39;&gt;&#39;, &#39;大于&#39;),</span>
<span class="c1">#         &#39;lte&#39;: (&#39;&lt;=&#39;, &#39;小于等于&#39;),</span>
<span class="c1">#         &#39;gte&#39;: (&#39;&gt;=&#39;, &#39;大于等于&#39;),</span>
<span class="c1">#         &#39;and&#39;: (And, &#39;并且&#39;),</span>
<span class="c1">#         &#39;or&#39;: (Or, &#39;或者&#39;),</span>
<span class="c1">#         &#39;implies&#39;: (Implies, &#39;则&#39;)</span>
<span class="c1">#     }</span>

<span class="c1">#     def generate_operand(domain_config):</span>
<span class="c1">#         # 处理离散集合（列表、range、NumPy数组等）</span>
<span class="c1">#         if isinstance(domain_config, (list, range, np.ndarray)):</span>
<span class="c1">#             if isinstance(domain_config, np.ndarray):</span>
<span class="c1">#                 return np.random.choice(domain_config)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return random.choice(list(domain_config))</span>
<span class="c1">#         # 处理连续区间（通过元组表示范围，如(0,1)）</span>
<span class="c1">#         elif isinstance(domain_config, tuple) and len(domain_config) == 2:</span>
<span class="c1">#             return random.uniform(domain_config[0], domain_config[1])</span>
<span class="c1">#         else:</span>
<span class="c1">#             return domain_config</span>

<span class="c1">#     def build_expr(config_node):</span>
<span class="c1">#         &quot;&quot;&quot;递归构建表达式与描述&quot;&quot;&quot;</span>
<span class="c1">#         if not isinstance(config_node, dict):  # 叶子节点（变量/常量）</span>
<span class="c1">#             val = generate_operand(config_node)</span>
<span class="c1">#             display_val = val.decl().name() if isinstance(val, z3.ExprRef) else val</span>
<span class="c1">#             if isinstance(display_val, bool):</span>
<span class="c1">#                 display_val = &#39;真&#39; if display_val else &#39;假&#39;</span>
<span class="c1">#             return val, display_val</span>

<span class="c1">#         # 解析当前节点配置</span>
<span class="c1">#         candidates_operators = list(op_translation.keys()) if (not isinstance(config_node[&quot;operand_l&quot;], dict) and not isinstance(config_node[&quot;operand_r&quot;], dict)) else [&quot;and&quot;, &quot;or&quot;, &quot;implies&quot;]</span>
<span class="c1">#         operators = config.get(&#39;operator&#39;, candidates_operators)</span>
<span class="c1">#         if type(operators) != list:</span>
<span class="c1">#             operators = [operators]</span>
<span class="c1">#         op_type = random.choice(operators)</span>
<span class="c1">#         op_symbol, op_desc = op_translation[op_type]</span>
<span class="c1">#         left_expr, left_desc = build_expr(config_node[&#39;operand_l&#39;])</span>
<span class="c1">#         right_expr, right_desc = build_expr(config_node[&#39;operand_r&#39;])</span>

<span class="c1">#         # 构建Z3表达式</span>
<span class="c1">#         z3_op, _ = op_translation[op_type]</span>
<span class="c1">#         if callable(z3_op):</span>
<span class="c1">#             z3_expr = z3_op(left_expr, right_expr)</span>
<span class="c1">#         else:</span>
<span class="c1">#             z3_expr = eval(f&quot;left_expr {z3_op} right_expr&quot;)</span>

<span class="c1">#         # 准备模板变量</span>
<span class="c1">#         template_vars = {</span>
<span class="c1">#             &#39;_operator&#39;: op_symbol,</span>
<span class="c1">#             &#39;_operand_l&#39;: left_expr,</span>
<span class="c1">#             &#39;_operand_r&#39;: right_expr,</span>
<span class="c1">#             **(_user_context_global or {}),</span>
<span class="c1">#             **(_user_context_local or {}),</span>
<span class="c1">#             **(globals())</span>
<span class="c1">#         }</span>
<span class="c1">#         # print(template_vars[&quot;students&quot;], template_vars[&quot;_index&quot;])</span>
<span class="c1">#         # print(_user_context_local)</span>

<span class="c1">#         # 渲染描述模板</span>
<span class="c1">#         # desc_template = config_node.get(&#39;desc&#39;, </span>
<span class="c1">#         #     f&quot;{left_desc} {op_desc} {right_desc}&quot;</span>
<span class="c1">#         # )</span>

<span class="c1">#         template = SafeTemplate(config_node.get(&#39;desc&#39;, f&quot;{left_desc} {op_desc} {right_desc}&quot;))</span>
<span class="c1">#         description = template.render(template_vars)</span>

<span class="c1">#         # description = eval(f&quot;f&#39;{desc_template}&#39;&quot;, None, template_vars)</span>

<span class="c1">#         return z3_expr, description</span>

<span class="c1">#     return build_expr(config)</span>

<div class="viewcode-block" id="make_expr">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.make_expr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_expr</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a Z3 expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        op (str): Operator identifier, supporting the following forms:</span>

<span class="sd">            - Comparison operators: `&quot;eq&quot;`/`&quot;==&quot;`, `&quot;neq&quot;`/`&quot;!=&quot;`, `&quot;gt&quot;`/`&quot;&gt;&quot;`, `&quot;ge&quot;`/`&quot;&gt;=&quot;`, `&quot;lt&quot;`/`&quot;&lt;&quot;`, `&quot;le&quot;`/`&quot;&lt;=&quot;`</span>
<span class="sd">            </span>
<span class="sd">            - Logical operators: `&quot;and&quot;`/`&quot;&amp;&amp;&quot;`, `&quot;or&quot;`/`&quot;||&quot;`, `&quot;not&quot;`/`&quot;!&quot;`, `&quot;implies&quot;`/`&quot;=&gt;&quot;`</span>
<span class="sd">            </span>
<span class="sd">            - Arithmetic operators: `&quot;add&quot;`/`&quot;+&quot;`, `&quot;sub&quot;`/`&quot;-&quot;`, `&quot;mul&quot;`/`&quot;*&quot;`, `&quot;div&quot;`/`&quot;/&quot;`</span>

<span class="sd">        *operands (z3.ExprRef): Z3 expression operands, the number determined by the operator:</span>

<span class="sd">            - Unary operators: 1 operand (e.g., `not`)</span>

<span class="sd">            - Binary operators: 2 operands (e.g., `+`, `==`)</span>

<span class="sd">            - N-ary operators: Any number (e.g., `and`, `or`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        z3.ExprRef: The generated Z3 expression object.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: </span>
<span class="sd">            - When an unsupported operator is used.</span>
<span class="sd">            - When the number of operands does not meet the operator&#39;s requirements.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; make_expr(&quot;&gt;=&quot;, x, 5)     # Creates x &gt;= 5</span>
<span class="sd">        &gt;&gt;&gt; make_expr(&quot;&amp;&amp;&quot;, x &gt; 0, y &lt; 10)  # Creates And(x &gt; 0, y &lt; 10)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Logical operators `and`/`or` support any number of operands.</span>
<span class="sd">        - Arithmetic operator `+` actually calls the `Sum` function (e.g., `a + b + c` converts to `Sum(a, b, c)`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 运算符映射表（支持 &quot;eq&quot; 和 &quot;==&quot; 两种形式）</span>
    <span class="n">op_to_z3_func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># 比较运算符</span>
        <span class="s2">&quot;eq&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">,</span>   <span class="s2">&quot;==&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;neq&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">,</span>   <span class="s2">&quot;!=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;gt&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>    <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;ge&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">,</span>   <span class="s2">&quot;&gt;=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;lt&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span>    <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;le&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">,</span>   <span class="s2">&quot;&lt;=&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">,</span>
        <span class="c1"># 逻辑运算符</span>
        <span class="s2">&quot;and&quot;</span><span class="p">:</span> <span class="n">And</span><span class="p">,</span>     <span class="s2">&quot;&amp;&amp;&quot;</span><span class="p">:</span> <span class="n">And</span><span class="p">,</span>
        <span class="s2">&quot;or&quot;</span><span class="p">:</span> <span class="n">Or</span><span class="p">,</span>       <span class="s2">&quot;||&quot;</span><span class="p">:</span> <span class="n">Or</span><span class="p">,</span>
        <span class="s2">&quot;not&quot;</span><span class="p">:</span> <span class="n">Not</span><span class="p">,</span>     <span class="s2">&quot;!&quot;</span><span class="p">:</span> <span class="n">Not</span><span class="p">,</span>
        <span class="s2">&quot;implies&quot;</span><span class="p">:</span> <span class="n">Implies</span><span class="p">,</span> <span class="s2">&quot;=&gt;&quot;</span><span class="p">:</span> <span class="n">Implies</span><span class="p">,</span>
        <span class="c1"># 算术运算符</span>
        <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="n">Sum</span><span class="p">,</span>     <span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span>
        <span class="s2">&quot;sub&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;mul&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="s2">&quot;div&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># 检查运算符是否支持</span>
    <span class="k">if</span> <span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_to_z3_func</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported operator: &#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># 获取对应的 Z3 函数</span>
    <span class="n">z3_func</span> <span class="o">=</span> <span class="n">op_to_z3_func</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>

    <span class="c1"># 检查算子数量是否合法</span>
    <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;not&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&#39; requires exactly 1 operand&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="s2">&quot;ne&quot;</span><span class="p">,</span> <span class="s2">&quot;gt&quot;</span><span class="p">,</span> <span class="s2">&quot;ge&quot;</span><span class="p">,</span> <span class="s2">&quot;lt&quot;</span><span class="p">,</span> <span class="s2">&quot;le&quot;</span><span class="p">,</span> <span class="s2">&quot;==&quot;</span><span class="p">,</span> <span class="s2">&quot;!=&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&gt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;=&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&#39; requires exactly 2 operands&quot;</span><span class="p">)</span>
    <span class="c1"># 对于可变参数的运算符（如 And/Or），不检查数量</span>

    <span class="c1"># 动态调用 Z3 函数</span>
    <span class="k">return</span> <span class="n">z3_func</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span></div>



<div class="viewcode-block" id="to_hashable">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.to_hashable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">to_hashable</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively convert nested structures to hashable types.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        element (Any): Input element, supports nested lists/tuples.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Hashable object: Converts lists to tuples, preserving the nested structure.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; to_hashable([1, [2, 3]])  # Returns (1, (2, 3))</span>
<span class="sd">        &gt;&gt;&gt; to_hashable({1, 2})       # Returns the original set (since sets are not hashable).</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Mainly used to use nested structures as dictionary keys or set elements.</span>
<span class="sd">        - Only processes list types; other container types (e.g., dict) need to be handled separately.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">to_hashable</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">element</span></div>


<div class="viewcode-block" id="to_unique">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.to_unique">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">to_unique</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove duplicates from a list (preserving order).</span>

<span class="sd">    Parameters:</span>
<span class="sd">        l (Union[list, Any]): Input list or any type.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A deduplicated list (maintaining the order of elements); returns the input directly if it&#39;s not a list.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; to_unique([1, 2, 1, 3])  # Returns [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; to_unique(&quot;abcaba&quot;)      # Returns [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">l</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
        <span class="n">item_hash</span> <span class="o">=</span> <span class="n">to_hashable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">item_hash</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item_hash</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="sort_solutions">
<a class="viewcode-back" href="../../utils.html#utils.auxiliary_operator.sort_solutions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sort_solutions</span><span class="p">(</span><span class="n">solutions</span><span class="p">,</span> <span class="n">key_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort the list of solutions obtained from the Z3 solver.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        solutions (list): The list of solutions to be sorted, where each element is a Z3 model.</span>
<span class="sd">        key_func (callable, optional): A function to generate the sorting key, which takes a model and returns a sortable value. Defaults to a tuple of values sorted by variable names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solutions</span><span class="p">:</span>
        <span class="k">return</span>  <span class="c1"># 无解，无需排序</span>
    
    <span class="k">if</span> <span class="n">key_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># 提取所有变量并按名称排序</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">solutions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        
        <span class="k">def</span><span class="w"> </span><span class="nf">default_key</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
                <span class="c1"># 将所有值统一转换为字符串</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">IntNumRef</span><span class="p">):</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">as_long</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
                    <span class="c1"># 将布尔值转换为字符串 &quot;True&quot; 或 &quot;False&quot;</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">is_true</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">BitVecNumRef</span><span class="p">):</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">as_signed_long</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>  <span class="c1"># 其他类型转为字符串</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        
        <span class="n">key_func</span> <span class="o">=</span> <span class="n">default_key</span>
    
    <span class="c1"># 原地排序</span>
    <span class="n">solutions</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Anonymous Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>